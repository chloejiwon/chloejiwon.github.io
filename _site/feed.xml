<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-08-09T00:55:04+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">JJIONI NOTES</title><subtitle>NOTES, ...</subtitle><author><name>JJIONI</name></author><entry><title type="html">IBM Cloud Essentials Badge 획득하기</title><link href="http://localhost:4000/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C/ibm-clouders-notetaking/" rel="alternate" type="text/html" title="IBM Cloud Essentials Badge 획득하기" /><published>2020-08-09T00:00:00+00:00</published><updated>2020-08-09T06:11:00+00:00</updated><id>http://localhost:4000/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C/ibm-clouders-notetaking</id><content type="html" xml:base="http://localhost:4000/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C/ibm-clouders-notetaking/">&lt;blockquote&gt;
  &lt;p&gt;ibm CLouders로 활동하면서 ibm CLoud Essentials 강의 들으며 note taking한 거 공유하는 글이다. 클라우드의 개략적인 개념을 이해할 수 있어서 좋았다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;iaas--paas--saas&quot;&gt;Iaas / Paas / Saas&lt;/h1&gt;

&lt;p&gt;aaS = as a Service, how you consume&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Iaas : Infrastructure. For example, my computer, some random other person’s computer running somewhere else …
    &lt;ul&gt;
      &lt;li&gt;persona of Iaas is “System admin”&lt;/li&gt;
      &lt;li&gt;It’s like a “leasing a car”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Paas : Platform.
    &lt;ul&gt;
      &lt;li&gt;persona is “Developer”&lt;/li&gt;
      &lt;li&gt;renting a car&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Saas : Software
    &lt;ul&gt;
      &lt;li&gt;taking taxi / Uber&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/image-20200809084416216.png&quot; alt=&quot;image-20200809084416216&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;cloud-native&quot;&gt;Cloud Native&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://d1fto35gcfffzn.cloudfront.net/images/topics/cloudnative/diagram-cloud-native.png&quot; alt=&quot;Cloud-Native&quot; style=&quot;zoom:33%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Microservice, Container를 Cloud native application으로 개발&lt;/p&gt;

&lt;h1 id=&quot;infrastructure-services&quot;&gt;Infrastructure Services&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Bare Metal Server ?
    &lt;ul&gt;
      &lt;li&gt;A dedicated physical server which is yours to use and manage from the ‘metal up’&lt;/li&gt;
      &lt;li&gt;No sharing of underlying hardware&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;virtual-private-cloud-vpc&quot;&gt;Virtual Private Cloud (VPC)&lt;/h2&gt;

&lt;p&gt;traditional cloud works like this. Network engineers have to do all network system things. routers, VPN, …&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/image-20200809092240180.png&quot; alt=&quot;image-20200809092240180&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;However «Virtual Networking» , all of these capabilities is given as a service. User can create these functions and the segmentation with a UI or CLI or API without knowing any proprietary interfaces.&lt;/p&gt;

&lt;p&gt;VPC is isolated logical network that you create. this includes Multi Region Zone(MZR), Sequrity Groups , Connectivity. Other services are provided to support VPC like Load Balancing.&lt;/p&gt;

&lt;h2 id=&quot;vmware&quot;&gt;VMWare&lt;/h2&gt;

&lt;p&gt;What IBM cloud gives:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Data sovereignty compliance - Geo-Fencing for workloads,  Data doeson’t cross borders&lt;/li&gt;
  &lt;li&gt;Compliance and regulatory control&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;https://tanzu.vmware.com/kr/cloud-native&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>JJIONI</name></author><category term="cloud" /><summary type="html">IBM CLOUD essentials 무료강의 듣고 badge 따자!</summary></entry><entry><title type="html">WebRTC로 실시간 영상 통화를 하며 Object Detection을 해보자 - 1탄</title><link href="http://localhost:4000/%EC%9B%B9,%20%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/webrtc+tensorflow/" rel="alternate" type="text/html" title="WebRTC로 실시간 영상 통화를 하며 Object Detection을 해보자 - 1탄" /><published>2020-07-29T00:00:00+00:00</published><updated>2020-07-26T06:11:00+00:00</updated><id>http://localhost:4000/%EC%9B%B9,%20%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/webrtc+tensorflow</id><content type="html" xml:base="http://localhost:4000/%EC%9B%B9,%20%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/webrtc+tensorflow/">&lt;blockquote&gt;
  &lt;p&gt;프로젝트 진행하면서 처음 접한 webrtc.. 실시간으로 영상 채팅하며tensorflow js 모델과 함께 객체 인식을 하는 기능을 구현해보는데… 👀&lt;/p&gt;

  &lt;p&gt;왕왕 초보라 틀린 정보가 있을 수 있음을 미리 고지합니다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;-table-of-contents&quot;&gt;📌 Table of Contents&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#🚦webrtc가-뭐냐&quot;&gt;WebRTC가 뭐냐?&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#webrtc-동작방식&quot;&gt;webrtc 동작방식&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#webrtc-구현하기&quot;&gt;WebRTC구현하기&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#N:N영상통화&quot;&gt;N:N영상통화&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tensorflow-js모델을-심자&quot;&gt;Tensorflow js모델을 심자&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#reference&quot;&gt;reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;-webrtc가-뭐냐&quot;&gt;🚦 webRTC가 뭐냐?&lt;/h1&gt;

&lt;p&gt;WebRTC는 web application간에 실시간 통신 기능을 제공하는 기술. 특히 마이크나 스피커, 영상같은 데이터를 실시간으로 peer connection으로 별도 서버 없이 가능하게 해준다.  (심지어 screen sharing도 가능하다고 함 ) 그럼 간단한 동작 방식을 살펴보자!&lt;/p&gt;

&lt;h2 id=&quot;webrtc-동작-방식&quot;&gt;webRTC 동작 방식&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://webrtc-security.github.io/images/diagram_1_en.png&quot; alt=&quot;webrtc-topology&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아주아주 간단한 webrtc topology는 위와 같다. Alice와 Bob이 각자 컴퓨터에서 browser를 키면, signaling server에 signal을 전송한다. Signaling은 RTCPeerConnection들이 적절하게 데이터를 교환할 수 있게 처리하는 복잡한 과정이다. Signaling server는 피어와 피어가 서로를 찾을 수 있도록 도와주는 서버. Signaling 단계에선 서로 Connection을 맺기 이전 아래와 같은 정보를 교환하도록 해줍니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Network 정보 교환
    &lt;ol&gt;
      &lt;li&gt;P2P 통신을 위해선 연결을 위한 각 client가 서로의 IP와 UDP port,  따위의 것을 알고 있어야 한다. WebRTC communication이 동작하기 전에 이 과정이 미리 되어 있어야 하는데, 이때 쓰이는 서버가 &lt;strong&gt;STUN&lt;/strong&gt; 서버이다.  STUN서버로 인해 서로 각client가 자기 IP를 알게 된다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Media Capability 교환&lt;/li&gt;
  &lt;li&gt;Session Control Message 교환&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;결국 시그널링을 통해 정보를 주고 받고 P2P connection을 맺는다. 그리고 그 후부턴 각 peer 로 각자의 media, data를 전송하면 된다. 👏🏻&lt;/p&gt;

&lt;h1 id=&quot;-webrtc-구현하기&quot;&gt;🎓 webRTC 구현하기&lt;/h1&gt;

&lt;p&gt;프로젝트에서 사용한 기본적인 뼈대 코드를 webRTC 엄청 고수로 추정되는 유투버가 제공하는 tutorial 로 구현한 부분을 공유해본다. simple peer를 이용하여 아주 간단한 예제를 학습해봤다.&lt;/p&gt;

&lt;p&gt;코드 전문은 여기서 확인 가능하다. 😎 (여기서 signaling server는 server.js)&lt;/p&gt;

&lt;p&gt;https://github.com/chloejiwon/coronabusters/tree/webrtc_basic_tutorial&lt;/p&gt;

&lt;h2 id=&quot;nn-영상통화&quot;&gt;N:N 영상통화&lt;/h2&gt;

&lt;p&gt;동작 Flow부터 먼저 확인하자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;client A가 브라우저에 접속하여, signaling server에 connection을 알린다.&lt;/li&gt;
  &lt;li&gt;clinet B가 브라우저에 접속하여 signaling server에 알린다. 엇 근데 기다리는 client A가 있네? signaling server는 A의 socket 정보를 B에 보낸다.&lt;/li&gt;
  &lt;li&gt;A의 정보를 받은 B는 A에 대해  createPeer 을 한다. 그리고 B의 peer signal를 signaling server에 전송한다.&lt;/li&gt;
  &lt;li&gt;signaling server에서는 B의 signal을 A에게 전송한다. A또한 peer을 만들고, A의 signal을 signaling server에 전송하고, peer에도 signal한다.&lt;/li&gt;
  &lt;li&gt;B가 signaling server에서 정보 받으면, A에게 signal한다. (이제 P2P연결이 맺어진 것. 각 peer로 data, media stream을 주고받을 수 있다.)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;내가 github에 구현해놓은 부분은 N:N 다대다 통신이다. 당연히 p2p 니까, 얘네는 모두가 모두랑 연결되어 있으면 되는거다. Client 한 명이 방에 들어오면 방에 있는 모든 친구들의 socket id 리스트를 보내준다. 그럼 새로 방에 들어온 client가 각 친구들에게 signal을 보내 peer connection을 맺는다. 모두가 모두랑 연결되어 있으므로 N명이 있다면 전체 connection의 갯수는 N*(N-1)/2 이다. (친구를 그래프의 노드라고 생각하면 연결할 수 있는 모든 간선의 수) 여기까지 하면 아주 간단하게 친구의 stream을 얻어와 서로 데이터 공유할 수 있다. 🎉&lt;/p&gt;

&lt;p&gt;root 폴더에서 아래 명렁어로 signaling server를 띄우고, (8000 포트 아무도 쓰지 않아야 함, 아님 설정을 바꿔주든지..?)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$node server.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;client/ 폴더에서는 view를 위해 아래 command 입력한다. (이건 3000번 포트 사용한다)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$npm run-script start
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;혹시 무슨 tensorflow coco-ssd 못 불러온다는 에러가 뜨면 아래 명령어 입력한다.&lt;/p&gt;

&lt;p&gt;왜 package.json에 있는데 install 따로 해줘야할까..? 😞&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install @tensorflow-models/coco-ssd
$ npm install @tensorflow/tfjs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하여튼 이렇게 하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://location:3000&lt;/code&gt;에 접속하면 create room화면이 뜨고, 누르면 자기 얼굴이 턱 등장.&lt;/p&gt;

&lt;p&gt;이제 나는 자기 비디오에 Tensorflow js 모델을 통해 object detection을 하고자 하는데 이거는 다음 편에 이어서 마무리하도록 하겠다. 🤟🏼&lt;/p&gt;

&lt;h1 id=&quot;-reference&quot;&gt;🎉 reference&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;http://jaynewho.com/post/36&lt;/li&gt;
  &lt;li&gt;http://webrtc.org&lt;/li&gt;
  &lt;li&gt;https://www.youtube.com/watch?v=R1sfHPwEH7A&lt;/li&gt;
&lt;/ul&gt;</content><author><name>JJIONI</name></author><category term="tensorflow, javascript" /><summary type="html">webrtc 와 tensorflow js 모델로 object detection해보기</summary></entry><entry><title type="html">추천 시스템 - Matrix Factorization 기초 원리와 구현 방법</title><link href="http://localhost:4000/recommend%20system/matrix-factorization/" rel="alternate" type="text/html" title="추천 시스템 - Matrix Factorization 기초 원리와 구현 방법" /><published>2020-05-30T00:00:00+00:00</published><updated>2020-05-30T06:11:00+00:00</updated><id>http://localhost:4000/recommend%20system/matrix-factorization</id><content type="html" xml:base="http://localhost:4000/recommend%20system/matrix-factorization/">&lt;h1 id=&quot;-table-of-contents&quot;&gt;🗒 Table of Contents&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#matrix-factorization-이란&quot;&gt;Matrix Factorization 무어냐?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#matrix-factorization의-기본개념&quot;&gt;Matrix Factorization의 기본 개념&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#matrix-factorization의-동작방식&quot;&gt;matrix factorization의 동작방식&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#marix-factorization-구현&quot;&gt;Matrix Factorization 구현&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#reference&quot;&gt;reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;matrix-factorization-이란&quot;&gt;Matrix Factorization 이란?&lt;/h1&gt;

&lt;h1 id=&quot;matrix-factorization의-기본개념&quot;&gt;Matrix Factorization의 기본개념&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Matrix Factorization을 이해하기 위하여 필요한 개념들을 정리해보자. 오랜만에 선형대수학 다루니까 굉장히 생소(?)하면서 재밌다. 🤪 기하학적 의미, 데이터적으로 생각했을때… 이렇게 여러 관점에서 생각하니까 의외로 이해가 좀 쉽다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;pca-principal-component-analysis&quot;&gt;PCA (Principal Component Analysis)&lt;/h2&gt;

&lt;p&gt;PCA는 데이터의 구조를 &lt;strong&gt;잘&lt;/strong&gt; 살려주면서 차원 감소를 할 수 있게 해주는 방법이다. 차원 감소를 위해선, 선형대수학적으로 &lt;strong&gt;정사영&lt;/strong&gt;이라는 방법을 이용한다. 그럼 우리는 어떤 벡터에 정사영 해야 데이터 구조를 &lt;strong&gt;잘&lt;/strong&gt; 살렸다고 소문이 날까? 🧐&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/25388D40527C43DB0B&quot; alt=&quot;2D에서의PCA&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 xy축에 있는 데이터들의 분포를 보자. 저 검정색이 데이터들을 모아놓은 거라고 한다면, 이 데이터의 분포 특성을 2개의 벡터로 가장 잘 설명할 수 있는 방법은 e1, e2 두 개의 벡터로 데이터 분포를 설명하는 것이다. e1의 방향과 크기 &amp;amp; e2의 방향과 크기를 알면 데이터 분포가 어떤 형태 인지 가장 단순하고 효과적으로 파악 할 수 있다. (데이터 하나 하나 분석하는 게 아니라, 하나의 분포를 이룰때를 분석하는 것). 근데 사실 e1, e2는 아무 축이나 될 수 있다. 하지만 데이터의 구조를 &lt;strong&gt;잘&lt;/strong&gt; 살리려면, 아무 축이나 잡아선 안된다! 기준은 분산이 크면 클 수록, 데이터의 구조를 잘 살린것. 그도 그럴게 분산이 크단 소리는 데이터를 차원 축소 시켜도, 각각의 특징이 잘 살아있단 소리니까. 그럼 축 중에서도 정사영 했을 때의 분산이 제~일 큰 축을 찾아야 하는 문제가 된다. 여기서 &lt;code class=&quot;highlighter-rouge&quot;&gt;공분산행렬&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;eigenvalue&lt;/code&gt; 와 &lt;code class=&quot;highlighter-rouge&quot;&gt;eigenvector&lt;/code&gt; 의 의미를 되살펴보자. &lt;code class=&quot;highlighter-rouge&quot;&gt;공분산행렬&lt;/code&gt;은 각 feature가 얼마나 서로 닮아있는가, 서로서로 영향을 끼치는가에 대한 정보를 담고 있다. X^T*X니까, 각 feature의 내적 값을 가지고 있는 행렬이다. (참고로 내적은, dot(a,b)라면, b라는 기준 벡터에서, a벡터가 얼마나 b의 성분을 가지고 있는가? 의 값이라고 생각해도 된다. ) 공분산행렬의 eigenvector는 공분산행렬의 그 행렬이 벡터에 작용하는 주축의 방향을 나타내므로, 데이터가 어떤 방향으로 분산되어 있는 지를 나타내준다. 그리고 eigenvalue는 그 eigenvector방향으로 얼마만큼의 크기로 벡터공간이 늘려지는 가를 의미하므로 eigenvalue 큰 값부터 eigenvector를 구하면 중요한 순서대로 주성분을 구하는 것이 된다.&lt;/p&gt;

&lt;p&gt;따라서 주성분인 e1과 e2는 데이터들을 평균 0으로 만들었을 때의 공분산의 &lt;code class=&quot;highlighter-rouge&quot;&gt;eigenvector&lt;/code&gt;이다. (2차원이니까 eigenvector 2개) 아무리 데이터를 늘리고 (=선형변환해도) 크기에만 영향받지 방향에는 영향을 받지 않는 벡터. 우리는 그런 벡터들에 정사영 시켜 차원을 축소 할 수 있다. 그리고 e1과 e2중에 데이터들의 분산(=variance)이 가장 큰 방향벡터는 e1에 해당한다. 즉 e1에 데이터를 정사영시켜 1차원의 데이터를 만들었을 때 우리는 데이터 구조를 아주 잘 살리며 차원을 감소했다고 말할 수 있다.
&lt;br /&gt;
PCA는 주성분을 분석하는건데, 그럼 주성분이 뭐야?! &lt;b&gt;주성분(Principle Component, Score)&lt;/b&gt;은 사영변환된 후의 변수이다. 그리고 주성분은 원래 변수들의 선형 결합으로 이루어졌다.&lt;/p&gt;

&lt;p&gt;&lt;del&gt;
여기서 우리가 주목해야하는 사실은 다음과 같다.
&lt;br /&gt;
주성분의 linear combination으로 original matrix를 표현할 수 있다는 것. 즉, 모든 사람의 얼굴은 각 특징들을 조합해서 만들 수 있다는 것 (좀 무섭다😂)
&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&quot;latent-factors&quot;&gt;Latent Factors&lt;/h3&gt;

&lt;p&gt;Latent Factor모형의 목적은 typical vector을 찾는것이다. 복잡한 사용자, 영화 특성을 몇개의 벡터로 간략화 하겠다는 것. 이때 쓰이는 방법이 PCA이다. 각 typical vector은 데이터에 해당하는 한 가지 특징을 가지고 있다. 예를 들어, 한 Typical guy는 &lt;strong&gt;늙은&lt;/strong&gt;사람, 한 typical guy는 &lt;strong&gt;안경 쓴&lt;/strong&gt;사람 등등…그리고 이러한 “늙었다” 거나 “안경을 쓴다” 는 특징을 &lt;strong&gt;Latent Factor&lt;/strong&gt;라고 부른다. 즉, 각 주성분은 특정한 하나의 latent factor를 가지고 있다.&lt;/p&gt;

&lt;h2 id=&quot;svd-singular-value-decomposition&quot;&gt;SVD (Singular Value Decomposition)&lt;/h2&gt;

&lt;p&gt;SVD는 임의의 M x N 차원의 행렬에 대해서 행렬의 곱으로 행렬을 분해하는 방법 중 하나이다. SVD는 R을 입력 받아, 다음과 같은 M, Σ(대각행렬), U를 반환하는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9909C6465B125C9E24&quot; alt=&quot;SVD공식&quot; /&gt;&lt;/p&gt;

&lt;p&gt;시그마는 대각행렬이고, 시그마를 제외하고 얘기해도 크게 문제가 없다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99D5E34A5B1261A81F&quot; alt=&quot;SVD공식2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99F01A445B12622833&quot; alt=&quot;rui공식&quot; /&gt;&lt;/p&gt;

&lt;p&gt;rui는 user가 item에 가지는 선호도라고 하자. pu는 user에 대한 정보, qi는 item에 대한 정보다.&lt;/p&gt;

&lt;h1 id=&quot;matrix-factorization-구현&quot;&gt;Matrix Factorization 구현&lt;/h1&gt;

&lt;p&gt;그럼 주어진 matrix R이 sparse하다면 빈 값을 어떻게 추정하여 구할 수 있을까? (= 추천시스템)
여러가지 방법이 있겠지만, Gradient Discent방식을 사용하여 구현해보자. (딥러닝에서 많이 쓰이는 방식) 랜덤한 값으로 p와 q를 셋팅하고 training하면서 RSME를 최소값으로 만드는 값을 찾는다. 아는 rui에 대해서 제일 좋은 p와 q를 찾아서, 나머지 빈 값을 계산하도록 한다.&lt;/p&gt;

&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;https://worthpreading.tistory.com/57&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://nicolas-hug.com/blog/matrix_facto_4&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://darkpgmr.tistory.com/110&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://nicolas-hug.com/blog/matrix_facto_1&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://www.youtube.com/watch?v=jNwf-JUGWgg&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>JJIONI</name></author><category term="recommend, algorithm" /><summary type="html">Python을 이용한 matrix factorization 구현</summary></entry><entry><title type="html">주소 창에 www.naver.com 치면 일어나는 일들</title><link href="http://localhost:4000/network/web-operation/" rel="alternate" type="text/html" title="주소 창에 www.naver.com 치면 일어나는 일들 " /><published>2020-05-05T00:00:00+00:00</published><updated>2020-05-05T06:11:00+00:00</updated><id>http://localhost:4000/network/web-operation</id><content type="html" xml:base="http://localhost:4000/network/web-operation/">&lt;h1 id=&quot;web-동작-원리&quot;&gt;WEB 동작 원리&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;빽 투더 베이직이다 ~ 탄탄 탄탄🧘🏻 ‍(수양 중) 주소창에 www.naver.com을 검색하면 어떤 일이 일어날까? 결국엔 WEB이란 어떻게 동작할까를 알아보자.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-table-of-contents&quot;&gt;🗒 Table of Contents&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#설마-이건-알겠지&quot;&gt;설마 이건 알겠지?&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ip-domain-dns&quot;&gt;IP와 Domain, DNS&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#web-동작방식&quot;&gt;WEB 동작방식&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#reference&quot;&gt;reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;설마-이건-알겠지&quot;&gt;설마 이건 알겠지?&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;아는 것 같은데 막상 설명해봐라! 하면 못할 수 있으니까 정리를 하자.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;ip-domain-dns&quot;&gt;IP Domain DNS&lt;/h3&gt;

&lt;h4 id=&quot;ip&quot;&gt;IP&lt;/h4&gt;

&lt;p&gt;Internet Protocol의 약자로, 네트워크상에서 컴퓨터가 다른 컴퓨터와 구별되어 지는 번호이다. 인터넷에 접속할때 컴퓨터 각각에 부여 받는 주소 혹은 전화번호라고 보면 됨.&lt;/p&gt;

&lt;h4 id=&quot;domain-name&quot;&gt;Domain Name&lt;/h4&gt;

&lt;p&gt;IP주소가 숫자로만 구성되어 있으니 외우기 힘들기 때문에, 이 IP주소를 문자로 표현한 도메인 주소 등장.(ex www.naver.com) 예를 들어, 010-1234-1234 외우고 다니기 힘드니까 핸드폰 전화번호부에 이건 A 이렇게 저장해 두는 것. 우리가 핸드폰에서 A에게 통화하기를 누르면, 실제로 ‘A’한테 전화거는게 아닌 010-1234-1234에 전화를 거는 것처럼 우리가 www.naver.com하면 해당 IP주소로 변경해서 접속해야 한다. 이렇게 domain name과 IP주소쌍을 한 쌍으로 가지고 있는 데이터 시스템을 &lt;strong&gt;DNS(Domain Name System)&lt;/strong&gt; 이라고 부른다.&lt;/p&gt;

&lt;h2 id=&quot;web-동작방식&quot;&gt;WEB 동작방식&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/web-operation.png&quot; alt=&quot;web동작방식&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;1-사용자가-웹-브라우저에-도메인-네임을-입력한다-주소창에-wwwnavercom을-친다&quot;&gt;1. 사용자가 웹 브라우저에 도메인 네임을 입력한다. (주소창에 www.naver.com을 친다)&lt;/h3&gt;

&lt;h3 id=&quot;2-웹-브라우저가-url을-해석한다&quot;&gt;2. 웹 브라우저가 URL을 해석한다.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;어떤 프로토콜을 사용하는지 .. 
  (http, telnet, ftp …)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ip 정보가 필요한지 (:다음에 //있으면 필요하다고 판단)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-url문법에-맞으면-punycode-encoding을-url의-host부분에-적용하고-hstshttp-strict-transport-security목록-로드해서-확인한다&quot;&gt;3. URL문법에 맞으면, punycode encoding을 url의 host부분에 적용하고 HSTS(HTTP strict Transport Security)목록 로드해서 확인한다.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;url 문법 안맞으면 그냥 기본 검색엔진으로 넘어감&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;hsts 목록에 있으면 https로 보내고 아니면 http로 보냄&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-dns-domain-name-server에-조회한다&quot;&gt;4. DNS (Domain Name Server)에 조회한다.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Browser에 해당 domain이 cache되어 있나 확인! 되어있으면 굳이 서버 조회 안해도 됨&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;없으면, 로컬에 저장돼 있는 hosts파일에서 참조할 수 있는 Domain이 있는지 확인한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모두 없으면 Network Stack에 구성되어 있는 DNS로 요청을 보낸다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DNS는 도메인 주소에 해당하는 ip 주소를 알려준다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-arpaddress-resolution-protocol로-대상의-ip와-mac-address를-알아낸다&quot;&gt;5. ARP(Address Resolution Protocol)로 대상의 IP와 MAC address를 알아낸다.&lt;/h3&gt;

&lt;h3 id=&quot;6-대상과-tcp-통신을-통해-socket을-연다&quot;&gt;6. 대상과 TCP 통신을 통해 socket을 연다.&lt;/h3&gt;

&lt;p&gt;1) 브라우저가 대상 서버의 IP 주소를 받으면 URL에서 해당 포트 번호(HTTP의 기본값은 80, HTTPS의 기본값은 443)를 가져와서, TCP Socket stream 요청&lt;/p&gt;

&lt;p&gt;2) TCP segment가 만들어지는 Transport Layer(OSI Model Layer 4)로 전달. 대상 포트 header에 추가되고 source port는 시스템에서 동적 포트 범위내에서 임의 지정&lt;/p&gt;

&lt;p&gt;3) TCP segment를 Network Layer(OSI Model Layer 3)로 전달. segment header에 대상 컴퓨터의 IP주소와 현재 컴퓨터의 IP주소가 삽입된packet 구성&lt;/p&gt;

&lt;p&gt;4) packet이 Link Layer(OSI Model Layer 2)로 전달. 시스템의 MAC address와 gateway(local router)의 MAC주소를 포함하는 Frame header 추가 (gateway의 MAC address를 모르는경우 ARP를 이용해 찾아야 한다.)&lt;/p&gt;

&lt;p&gt;5) packet이 ethernet, Wifi, Cellular data network 중 하나로 전송&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 광인터넷을 쓸 경우 modem을 통해 광신호로 변경된 후 network node로 직접 전송
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;6) packet local subnet router 도착, AS(Autonomous System)경계 router들을 통과&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  해당 라우터에선 packet의 IP header에서 target address를 추출하여 적당한 다음 hop으로 routing 

  IP header의 TTL(Time To Live)필드는 통과하는 라우터의 대해 하나씩 감소

  TTL필드가 0이 되거나 현재 router 대기열에 공간이 없으면 네트워크 정체로 packet 삭제
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tcp-operation.jpeg&quot; alt=&quot;TCP socket 통신 과정&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;7-https인-경우-ssltls-handshake가-추가된다&quot;&gt;7. HTTPS인 경우 SSL(TLS) handshake가 추가된다.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;TCP socket 통신과정 전에 TLS 통신이 추가된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;8-http-프로토콜로-요청한다&quot;&gt;8. HTTP 프로토콜로 요청한다.&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
GET / HTTP/1.1
Host: google.com
Connection: close
[other headers]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;서버로 부터 html 응답을 받는다.&lt;/p&gt;

&lt;h3 id=&quot;9-http서버가-응답한다&quot;&gt;9. HTTP서버가 응답한다.&lt;/h3&gt;

&lt;p&gt;HTTPD(HTTP daemon) 서버는 요청 / 응답을 처리하는 서버이다. 가장 일반적인 HTTPD 서버는 Linux의 경우 Apache 또는 Nginx이고 Windows의 경우 IIS이다.&lt;/p&gt;

&lt;h3 id=&quot;10-웹-브라우저가-그린다&quot;&gt;10. 웹 브라우저가 그린다.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;서버가 리소스를 브라우저에게 제공하면 브라우저는 렌더링 등을 수행하여 화면을 그린다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;reference&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;https://sophia2730.tistory.com/entry/DNS-%EC%A3%BC%EC%86%8C%EC%B0%BD%EC%97%90-wwwnavercom%EC%9D%84-%EC%B9%98%EB%A9%B4-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EC%9D%BC&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://github.com/SantonyChoi/what-happens-when-KR#id7&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>JJIONI</name></author><category term="web, network" /><summary type="html">WEB 동작 원리</summary></entry><entry><title type="html">docker 좋은데 ?! - 1</title><link href="http://localhost:4000/docker/docker-basics-first/" rel="alternate" type="text/html" title="docker 좋은데 ?! - 1 " /><published>2020-04-27T00:00:00+00:00</published><updated>2020-04-27T22:42:00+00:00</updated><id>http://localhost:4000/docker/docker-basics-first</id><content type="html" xml:base="http://localhost:4000/docker/docker-basics-first/">&lt;blockquote&gt;
  &lt;p&gt;일단 docker의 기본 개념을 (대충) 알아보자. 나도 잘 모르니깐…😛 (대충) 해보니까 드는 생각은 너무 편하다 👏🏻 매번 환경설정 맞춰 줘야 되고.. 버전 맞춰줘야 될 일 없어서..! 하물며 강의 들으면서 공부하는데 조차 !!!! 패키지, 버전때문에 골치아플 일 없어서 너무 좋다. 휴~ 그리고 난 내 로컬에 뭐 잘못될때마다 자꾸 까는게 싫어… 도커로 개발하면서 알게된 내용은 계속 추가 예정이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-table-of-contents&quot;&gt;🗒 Table of Contents&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#docker란&quot;&gt;docker가 무어냐?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#docker의-기본개념&quot;&gt;docker의 기본 개념&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#docker의-동작방식&quot;&gt;docker의 동작방식&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#docker의-이미지&quot;&gt;docker의 이미지&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#docker의-컨테이너&quot;&gt;docker의 컨테이너&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#실제-수행기&quot;&gt;실제 수행기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#reference&quot;&gt;reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;docker란&quot;&gt;docker란?&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;컨테이너 기반의 오픈소스 가상화 플랫폼&lt;/strong&gt;이다. 다양한 프로그램, 실행환경을 컨테이너로 추상화하여 동일한 인터페이스를 제공해서 프로그램의 배포 및 관리를 단순화하게 해준다. 그리고 어디에서나 실행할 수 있도록 해준다. 내가 경험한 docker로 말하자면, 어떤 환경에서, 얼마나 패키지가 업데이트 진행된 상태더라도(=시간이  흘렀어도) 똑같은 프로그램이 똑같이 동작하게 된다는 거다. &lt;code class=&quot;highlighter-rouge&quot;&gt;내 코드에는 전혀 이상 없는것 같은데 왜 안돼?&lt;/code&gt;하면서 구글링하며 삽질하는 시간을 save할 수 있다는 점 😌&lt;/p&gt;

&lt;h2 id=&quot;docker의-기본개념&quot;&gt;docker의 기본개념&lt;/h2&gt;

&lt;h3 id=&quot;docker의-동작방식&quot;&gt;docker의 동작방식&lt;/h3&gt;

&lt;p&gt;docker는 OS-level 가상화 툴이다. 그럼 기존의 VMware, Virtual Box같은 가상화머신과 뭐가 다를까? 가장 큰 차이는 OS-level이냐, Hardaware-level이냐 하는 것. 어떤 수준의 가상화를 제공하는 것이냐! 이다. 가상머신은 호스트OS위에 게스트OS전체를 가상화하여 사용하는 방식이다. 사용법은 간단하나 무겁고 느리다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;(참고) 너무 느리니까 CPU 가상화기술 HVM방식의 KVM (kernel-based virual machine)과 반가상화 방식의 Xen이 등장한다. 호스트형 가상화 방식에 비해 성능이 향상되었고, 이 기술들은 OpenStack이나, AWS 같은 클라우드서비스에서 가상 컴퓨팅 기술의 기반이 되었다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;추가적인 OS를 설치하여 가상화하는 건 아무리 해도 너무 느려! 그래서 &lt;strong&gt;프로세스&lt;/strong&gt;를 격리하는 방식이 등장한다. 프로세스만 격리되기 때문에 빠르고, CPU나 메모리도 프로세스가 필요한 만큼만 추가로 사용되기 때문에 성능 손실이 거의 없다.&lt;/p&gt;

&lt;h3 id=&quot;docker의-이미지&quot;&gt;docker의 이미지&lt;/h3&gt;

&lt;p&gt;이미지는 컨테이너 실행에 필요한 파일과 설정값등을 포함하고 있는 것으로 상태값을 가지지 않으며 변하지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;docker의-컨테이너&quot;&gt;docker의 컨테이너&lt;/h3&gt;

&lt;p&gt;Container 기술이 아주 중요한것 같지만 좀 방대한 것 같으므로, 일단 정의만 알아보자. 일단 컨테이너는 호스트OS상에 논리적인 구획을 만들고 어플리케이션을 작동시키기 위해 필요한 어플리케이션 등을 하나로 모아 마치 별도의 서버인 것처럼 사용할 수 있게 만든 것이다. 하드웨어 에뮬레이터 없이 리눅스 커널을 공유해서 바로 실행한다.&lt;/p&gt;

&lt;h2 id=&quot;실제-수행기&quot;&gt;실제 수행기&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;공부하려니까 docker가 그냥 막연히 재밌어 보여서 이미지를 한번 만들어 보았다. 실제로 재밌었고, 나의 로컬을 깨끗이 하며 나의 딥러닝 프로젝트는 저 컨테이너에서 진행을 하겠다 !&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;일단 기본이 되는 ubuntu 18.04 이미지를 받아왔다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker pull ubuntu:18.04&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  ~ docker pull ubuntu:18.04
18.04: Pulling from library/ubuntu
23884877105a: Pull &lt;span class=&quot;nb&quot;&gt;complete 
&lt;/span&gt;bc38caa0f5b9: Pull &lt;span class=&quot;nb&quot;&gt;complete 
&lt;/span&gt;2910811b6c42: Pull &lt;span class=&quot;nb&quot;&gt;complete 
&lt;/span&gt;36505266dcc6: Pull &lt;span class=&quot;nb&quot;&gt;complete 
&lt;/span&gt;Digest: sha256:3235326357dfb65f1781dbc4df3b834546d8bf914e82cce58e6e6b676e23ce8f
Status: Downloaded newer image &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;ubuntu:18.04
docker.io/library/ubuntu:18.04
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;내가 제대로 받아왔는지 봐보자
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker image ls&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  ~ docker image &lt;span class=&quot;nb&quot;&gt;ls
&lt;/span&gt;REPOSITORY                      TAG                 IMAGE ID            CREATED             SIZE
ubuntu                          18.04               c3c304cb4f22        4 days ago          64.2MB
chloejiwon/deeplearningbasics   pytorch             2328f41a83f4        9 days ago          6.79GB
ubuntu                          latest              4e5021d210f6        5 weeks ago         64.2MB
deeplearningzerotoall/pytorch   latest              2b3fd7327ec7        13 months ago       4.14GB
hello-world                     latest              fce289e99eb9        16 months ago       1.84kB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위에 보면 ubuntu REPOSITORY에 18.04 TAG 되어있는 이미지가 잘 생성된 걸 확인할 수 있다. 그럼 이 이미지를 컨테이너로 실행시켜보자!&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker run -i -it ubuntu /bin/bash&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;oh ho~ 이제 컨테이너 실행시키고 그 안에 들어온 걸 알 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  ~ docker run &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; ubuntu:18.04 /bin/bash
root@640d6ef0849d:/# 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 여기서 ubuntu에서 하는 것처럼 이것저것 내가 필요한 것들을 설치해주면 된다.
나는 이것들을 깔았다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;git&lt;/li&gt;
  &lt;li&gt;anaconda&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;되게 많이한 것 같은데 기억이 안나네;&lt;/p&gt;

&lt;p&gt;~~ 자세한 부분은 추후 ~~&lt;/p&gt;

&lt;p&gt;그럼 이제 내가 만든 이미지를 내 허브에 올려서 내가 로컬을 옮길때마다 다운받을 수 있도록 하면 좋겠다!&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker stop &amp;lt;&amp;lt;내가 실행한 컨테이너 이름&amp;gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(이름은 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker ps -a&lt;/code&gt;해서 알아낼 수 있음)&lt;/p&gt;

&lt;p&gt;그리고 지금까지의 컨테이너를 이미지화 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker commit -a &quot;&amp;lt;&amp;lt;author name&amp;gt;&amp;gt;&quot; &amp;lt;&amp;lt;container_id&amp;gt;&amp;gt; image_name/tag&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker images&lt;/code&gt;하면 아마 내가 만든 이름을 찾을 수 있을 것이다!&lt;/p&gt;

&lt;div class=&quot;language-zsh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  ~ docker commit &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;chloejiwon&quot;&lt;/span&gt; busy_gould test1/test 
sha256:b06a2521461631c2c394f5a025ff7ba6825fa13c29444b47f615ed8d89fe762d
➜  ~ 
➜  ~ docker images
REPOSITORY                      TAG                 IMAGE ID            CREATED             SIZE
test1/test                      latest              b06a25214616        3 seconds ago       64.2MB
ubuntu                          18.04               c3c304cb4f22        4 days ago          64.2MB
chloejiwon/deeplearningbasics   pytorch             2328f41a83f4        9 days ago          6.79GB
ubuntu                          latest              4e5021d210f6        5 weeks ago         64.2MB
deeplearningzerotoall/pytorch   latest              2b3fd7327ec7        13 months ago       4.14GB
hello-world      
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;그럼 이제 내가 잘 만든 이미지를 docker hub에 업로드 해보자&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker tag test1/test chloejiwon/test:1.0&lt;/code&gt;
우리가 생성한 이미지의 이름을 repository에 업로드하기 위해 고유 태그로 바꾼다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker push chloejiwon/test:1.0&lt;/code&gt;
하면, 이제 막 내 docker hub에 push 된다. 쭉쭉..&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&amp;lt;5/26일 추가&amp;gt; 오메 신기한겨… IBM Cloud에서 제공해주는 &lt;code class=&quot;highlighter-rouge&quot;&gt;웹사이트에서 코로나19(COVID-19) 위기 대응 커뮤니케이션 챗봇 통합하기&lt;/code&gt; 튜토리얼을 한번 해보려고 했고, 또 로컬에 깔기 싫어서 ubuntu docker 이미지 사용했다. ubuntu 컨테이너에다가 curl 깔고 IBM Cloud CLI 깔아야 된다 그러길래(튜토리얼 무한 신뢰) 깔았는데 docker container안에 또 docker를 깔게 되었다. 🤪 잘 되려나? 안 되어도 잘 되어도 글로 남겨둬야지. 일단 까는 건 무사히 성공.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@3141372216ff:/# curl &lt;span class=&quot;nt&quot;&gt;-sL&lt;/span&gt; https://ibm.biz/idt-installer | bash
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;main] &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==[&lt;/span&gt; IBM Cloud Developer Tools &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;Linux/MacOS - Installer, v1.2.3 &lt;span class=&quot;o&quot;&gt;]==&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; Starting Update...
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;install_deps_with_apt_get] Checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;and updating &lt;span class=&quot;s1&quot;&gt;'apt-get'&lt;/span&gt; support on Linux
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;install_deps_with_apt_get] Installing package: software-properties-common
Get:1 http://security.ubuntu.com/ubuntu bionic-security InRelease &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;88.7 kB]                      
Get:2 http://ppa.launchpad.net/git-core/ppa/ubuntu bionic InRelease &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;20.7 kB]                    
Hit:3 http://archive.ubuntu.com/ubuntu bionic InRelease                                  
Hit:4 http://archive.ubuntu.com/ubuntu bionic-updates InRelease                                                     
Hit:5 http://archive.ubuntu.com/ubuntu bionic-backports InRelease                                                      
Get:6 http://ppa.launchpad.net/git-core/ppa/ubuntu bionic/main amd64 Packages &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;3174 B]                          
Fetched 113 kB &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;2s &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;51.9 kB/s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;                    
Reading package lists... Done
Hit:1 http://ppa.launchpad.net/git-core/ppa/ubuntu bionic InRelease 
Hit:2 http://archive.ubuntu.com/ubuntu bionic InRelease             
Hit:3 http://security.ubuntu.com/ubuntu bionic-security InRelease
Hit:4 http://archive.ubuntu.com/ubuntu bionic-updates InRelease
Hit:5 http://archive.ubuntu.com/ubuntu bionic-backports InRelease
Reading package lists... Done                      
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;install_deps_with_apt_get] Installing/updating external dependency: curl
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;install_deps_with_apt_get] Installing/updating external dependency: git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;curl update하고 git 깔고 여기까진 좋다 이거야.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;install_deps_with_apt_get] Please review any setup requirements &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'git'&lt;/span&gt; from: https://git-scm.com/downloads
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;install_docker] Installing/updating external dependency: docker
&lt;span class=&quot;c&quot;&gt;# Executing docker install script, commit: 26ff363bcf3b3f5a00498ac43694bf1c7d9ce16c&lt;/span&gt;
+ sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; apt-get update &lt;span class=&quot;nt&quot;&gt;-qq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;/dev/null
+ sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;DEBIAN_FRONTEND&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;noninteractive apt-get &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-qq&lt;/span&gt; apt-transport-https ca-certificates curl &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;/dev/null
debconf: delaying package configuration, since apt-utils is not installed
+ sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; curl &lt;span class=&quot;nt&quot;&gt;-fsSL&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;https://download.docker.com/linux/ubuntu/gpg&quot;&lt;/span&gt; | apt-key add &lt;span class=&quot;nt&quot;&gt;-qq&lt;/span&gt; - &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;/dev/null
Warning: apt-key output should not be parsed &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;stdout is not a terminal&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
+ sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; /etc/apt/sources.list.d/docker.list
+ sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; apt-get update &lt;span class=&quot;nt&quot;&gt;-qq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;/dev/null
+ &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
+ sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; apt-get &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-qq&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--no-install-recommends&lt;/span&gt; docker-ce &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;/dev/null
debconf: delaying package configuration, since apt-utils is not installed
If you would like to use Docker as a non-root user, you should now consider
adding your user to the &lt;span class=&quot;s2&quot;&gt;&quot;docker&quot;&lt;/span&gt; group with something like:

  &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;usermod &lt;span class=&quot;nt&quot;&gt;-aG&lt;/span&gt; docker your-user

Remember that you will have to log out and back &lt;span class=&quot;k&quot;&gt;in for &lt;/span&gt;this to take effect!

WARNING: Adding a user to the &lt;span class=&quot;s2&quot;&gt;&quot;docker&quot;&lt;/span&gt; group will grant the ability to run
         containers which can be used to obtain root privileges on the
         docker host.
         Refer to https://docs.docker.com/engine/security/security/#docker-daemon-attack-surface
         &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;more information.
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;install_docker] If you want to run docker without &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;run: &lt;span class=&quot;s2&quot;&gt;&quot;sudo groupadd docker &amp;amp;&amp;amp; sudo usermod -aG docker &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$USER&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;install_docker] Please review any setup requirements &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'docker'&lt;/span&gt; from: https://docs.docker.com/engine/installation/
Client: Docker Engine - Community
 Version:           19.03.9
 API version:       1.40
 Go version:        go1.13.10
 Git commit:        9d988398e7
 Built:             Fri May 15 00:25:18 2020
 OS/Arch:           linux/amd64
 Experimental:      &lt;span class=&quot;nb&quot;&gt;false
&lt;/span&gt;Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;docker 무사히 깔린듯.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;install_deps_with_apt_get] Installing/updating external dependency: kubectl
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   371  100   371    0     0   1170      0 &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;:--:-- &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;:--:-- &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;:--:--  1166
&lt;span class=&quot;c&quot;&gt;######################################################################## 100.0%&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;install_deps_with_apt_get] Please review any setup requirements &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'kubectl'&lt;/span&gt; from: https://kubernetes.io/docs/tasks/tools/install-kubectl/
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;install_deps_with_apt_get] Installing/updating external dependency: helm
Downloading https://get.helm.sh/helm-v2.16.7-linux-amd64.tar.gz
Preparing to &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;helm and tiller into /usr/local/bin
helm installed into /usr/local/bin/helm
tiller installed into /usr/local/bin/tiller
Run &lt;span class=&quot;s1&quot;&gt;'helm init'&lt;/span&gt; to configure helm.

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;kubectl 깔고.. (kubenetes 인듯?(잘모름))&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;install_ibmcloud] Installing IBM Cloud &lt;span class=&quot;s1&quot;&gt;'ibmcloud'&lt;/span&gt; CLI &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;platform &lt;span class=&quot;s1&quot;&gt;'Linux'&lt;/span&gt;...
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;install_ibmcloud] Downloading and installing IBM Cloud &lt;span class=&quot;s1&quot;&gt;'ibmcloud'&lt;/span&gt; CLI from: https://clis.cloud.ibm.com/install/linux
Current platform is linux64. Downloading corresponding IBM Cloud CLI...
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   118  100   118    0     0    149      0 &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;:--:-- &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;:--:-- &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;:--:--   149
  0 15.2M    0  112k    0     0    184      0 24:06:55  0:10:23 23:56:32     0
curl: &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;18&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; transfer closed with 15859412 bytes remaining to &lt;span class=&quot;nb&quot;&gt;read
&lt;/span&gt;Download failed. Please check your network connection. Quit installation.
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;install_ibmcloud] IBM Cloud &lt;span class=&quot;s1&quot;&gt;'ibmcloud'&lt;/span&gt; CLI &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;finished.
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;install_ibmcloud] Running &lt;span class=&quot;s1&quot;&gt;'ibmcloud --version'&lt;/span&gt;...

&lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;중간 생략----

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;install_plugins] Running &lt;span class=&quot;s1&quot;&gt;'ibmcloud plugin list'&lt;/span&gt;...
main: line 346: ibmcloud: &lt;span class=&quot;nb&quot;&gt;command &lt;/span&gt;not found
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;install_plugins] Finished installing/updating plugins
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;env_setup] WARN: Please restart your shell to &lt;span class=&quot;nb&quot;&gt;enable&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'ic'&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;ibmcloud!
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; Install finished.
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;main] &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==[&lt;/span&gt; Total &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt;: 846 seconds &lt;span class=&quot;o&quot;&gt;]==&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;뭔가 ibmcloud만 제대로 안깔린 것 같은데.. 🧐와 이거 안되어서 또 &lt;del&gt;개&lt;/del&gt;고생했는데 &lt;del&gt;( docker network 뒤져보고 외부 통신 안될때 이런거 찾아 보는데 …)&lt;/del&gt;ibm에서 CLI docker 이미지로 만들었네. 😀하하! 그럼 그렇지! 엄청 편하네. 다음 번엔 host 에 있는 폴더와 mount 하는 법 / docker container 로 개발 환경 만들기 (?아주 허접하지만!) 을 포스팅 해야겠다.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://moducon.kr/2018/wp-content/uploads/sites/2/2018/12/leesangsoo_slide.pdf&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://developer.ibm.com/kr/tutorials/create-a-covid-19-chatbot-embedded-on-a-website/&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>JJIONI</name></author><category term="docker, container" /><summary type="html">~ 아무것도 모르고 이미지 만들어보기 ~</summary></entry><entry><title type="html">HTTP / HTTPS / SSL / REST ??</title><link href="http://localhost:4000/network/https/" rel="alternate" type="text/html" title="HTTP / HTTPS / SSL / REST ??" /><published>2020-04-26T00:00:00+00:00</published><updated>2020-04-20T22:42:00+00:00</updated><id>http://localhost:4000/network/https</id><content type="html" xml:base="http://localhost:4000/network/https/">&lt;h2 id=&quot;-table-of-contents&quot;&gt;🗒 Table of Contents&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#http&quot;&gt;HTTP&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#https&quot;&gt;HTTPS&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ssl--tls&quot;&gt;SSL/TLS&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ssl-동작-방법&quot;&gt;SSL 동작 방법&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#rest&quot;&gt;REST&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#reference&quot;&gt;reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;http&quot;&gt;HTTP&lt;/h2&gt;

&lt;p&gt;HTTP는 Hypertext Transfer Protocol의 약자
Hyptertext인 HTML을 전송하기 위한 통신 규약을 의미한다.&lt;/p&gt;

&lt;h2 id=&quot;https&quot;&gt;HTTPS&lt;/h2&gt;

&lt;p&gt;HTTP + S : &lt;strong&gt;Over Secure Socket Layer&lt;/strong&gt;의 약자
보안이 강화된 HTTP라고 볼 수 있는데, 
HTTP는 암호화되지 않은 방법으로 데이터를 전송하기 때문에 서버와 클라이언트가 주고 받는 메시지가 아주 vulnerable 하기 때문에 보안을 강화한 HTTPS 가 나왔다! 
예를 들어, id / pw 같은 민감정보를 노출하면 안되기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;ssl--tls&quot;&gt;SSL / TLS&lt;/h2&gt;

&lt;p&gt;SSL 과 TLS 는 세션 계층에 포함되는 프로토콜이다. 
HTTPS는 SSL 위에서 돌아가는 서비스 중 하나 인 것.
그래서 HTTP가 SSL 프로토콜 위에서 동작한다면 HTTPS를 이용한다고 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;ssl-동작-방법&quot;&gt;SSL 동작 방법&lt;/h3&gt;

&lt;p&gt;SSL 동작 방법을 알기 전에, 대칭키와 공개키의 개념을 알아야 한다. 좀 신기하고 재밌음..&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;대칭키&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;a라는 value를 key를 가지고 암호화하여 서버에 전달하고, 서버는 동일한 key를 가지고 암호화된 value를 복호화한다. 
동작 방식을 보면, 서버와 클라이언트가 동일한 key를 가지고 암호화, 복호화하는데 이 키가 &lt;strong&gt;대칭키&lt;/strong&gt;인 것이다.
하지만, 누가 봐도 이 key만 알면 모든 암호화된 정보를 복호화하여 사용할 수 있기 때문에 등장한것이 &lt;strong&gt;공개키&lt;/strong&gt;이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;공개키&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;key가 두 개가 있다고 하자. A, B. 
A키로 암호화하면 B키로 복호화할 수 있고, vice versa. 이 방식이 공개키 방식이다.
A,B 키 중 하나를 private key(개인키, 비밀키)라고 하고, 나머지 하나를 public key(공개키)라고 한다.
private key는 본인만! 가지고 있고, public key는 타인에게 제공한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;인증서&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러면 인증서는 무어냐! 인증서의 기능은 &lt;code class=&quot;highlighter-rouge&quot;&gt;클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장하고, SSL통신에 사용할 공개키를 클라이언트에게 제공한다.&lt;/code&gt;이다. SSL을 통해서 암호화된 통신을 제공하려는 서비스는 CA(certiciate authority)를 통해서 인증서를 구입해야 한다. 
SSL 인증서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;서비스의 정보, 서버측 공개키&lt;/code&gt; 정보를 담고 있다. 그리고 이 내용이 CA의 &lt;strong&gt;private key&lt;/strong&gt;에 의해서 암호화된다. 그래서 절대 CA의 비공개키는 유출되면 안된다. 그럼 브라우저는 어떻게 CA의 비공개키로 암호화한 SSL인증서를 복호화하느냐? CA의 리스트를 알고 있기 때문이다. 공인된 CA는 브라우저가 미리 알고 있는 CA의 리스트에 포함되어 있다. 그리고 당연히 각 CA의 공개키도 알고 있겠지. 
그러면 어떻게 인증서가 서버의 신뢰성을 보장하느냐?
SSL 통신과정은 Handshake -&amp;gt; 전송(세션) -&amp;gt; Session 종료로 구성된다. 처음에 client와 server가 서로 인사부터 하는데, handshake 🤝라 부른다. 이때 뭘 할까?&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Client Hello (클라이언트가 서버에 접속한다.)
    &lt;ul&gt;
      &lt;li&gt;클라이언트 측에서 생성한 랜덤 데이터, 클라이언트가 지원하는 암호화 방식들, 세션 아이디&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Server Hello (Client hello에 대한 응답)
    &lt;ul&gt;
      &lt;li&gt;서버측에서 생성한 랜덤 데이터, 서버가 선택한 클라이언트의 암호화방식, &lt;strong&gt;인증서&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클라이언트는 서버의 인증서가 CA에 의해 발급된 !! 안전한!! 것이 맞는지 본인의 리스트를 쫙 확인한다. CA 리스트에 인증서 없다면? 사용자에게 경고 메시지 출력! CA 리스트에 있는 암호로 인해 복호화 성공했다면, CA의 개인키로 암호화된 문서임이 보증되어 서버를 믿을 수 있게 된 것이다. 😀(신뢰) 그리고 클라이언트에서 생성한 랜덤데이터와 서버가 생성한 랜덤데이터를 적절히 조합하여 pre mater secret이라는 키를 생성한다. 그리고 이 pre master key를 서버의 공개키로 암호화해서 서버에게 전송한다. 그럼 서버만 복호화 할 수 있게 되니깐. 🤓 (똑똑해..)&lt;/li&gt;
  &lt;li&gt;서버가 클라이언트가 전송한 pre master secret을 비공개키로 복호화했다. 그럼으로써 둘이 pre master secret 을 공유하게 된 것이다! 👏🏻 둘다 이 값을 master secret값으로 만들고, 이걸로 session key를 생성한다. 이 session key를 이용해서 서버와 클라이언트가 대칭키 방식으로 데이터를 암호화하여 주고 받게 된다.&lt;/li&gt;
  &lt;li&gt;핸드셰이크 단계 끝난 걸 서로에게 알림.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;앞으로 서버와 클라이언트가 주고받는 데이터는 session key 로 암호화된다. 근데 왜 그냥 공개키 사용하지, session key로 대칭키 방식으로 암호화할까? 공개키는 컴퓨팅파워를 많이 잡아먹기 때문…&lt;/p&gt;

&lt;p&gt;데이터 다 전송하면 서로 SSL 통신이 끝났음을 알리고 session key를 폐기한다.&lt;/p&gt;

&lt;h2 id=&quot;rest&quot;&gt;REST&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;RE&lt;/strong&gt;presentational &lt;strong&gt;S&lt;/strong&gt;tate &lt;strong&gt;T&lt;/strong&gt;ransfer&lt;/p&gt;

&lt;p&gt;the model of how Web application work&lt;/p&gt;

&lt;h3 id=&quot;어떻게-인터넷에서-정보를-공유할-것인가-&quot;&gt;어떻게 인터넷에서 정보를 공유할 것인가 ?&lt;/h3&gt;

&lt;p&gt;정보들을 하이퍼텍스트로 연결한다.&lt;/p&gt;

&lt;p&gt;표현형식 : HTML&lt;/p&gt;

&lt;p&gt;식별자 : URI&lt;/p&gt;

&lt;p&gt;전송 방법 : HTTP&lt;/p&gt;

&lt;h3 id=&quot;rest-란&quot;&gt;REST 란?&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;그 시작은 &lt;code class=&quot;highlighter-rouge&quot;&gt;어떻게 인터넷의 정보 전송 방법인 HTTP를 web을 breaking 하지 않으면서 개선할 수 있을까?&lt;/code&gt; 라는 질문이었다. Roy Fielding 의 박사학위 논문에서 REST가 최초 소개되었는데, 이 분은 HTTP/1.0, 1.1 스펙 작성에 참여했었고 아파치 HTTP 서버 프로젝트의 공동설립자이기도 하다. (크…🤟🏼)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;REST는 Web Service 를 만들때 사용되는 어떤 규칙을 가지고 있는 software architecture다. (Web service 뿐만 아니라 어떤 모델을 설계할때도 사용될 수 있다고 한다. 뭐, 결국 구조를 차용하면 되는거니까? ) 특별히 HTTP/1.1 스펙과 동시에 만들어져서(당연히 이거 만든 사람이 저거 만든거니까!!) HTTP 프로토콜을 정확히 사용할 수 있도록 디자인되어 있기 때문에 서비스를 멋지게(?)만드는 데 도움이 된다. 그리고 이런 REST 구조를 따라 설계된 Web Service를 &lt;strong&gt;RESTful&lt;/strong&gt; web service 라고 부른다. 그럼 서비스를 RESTful하게 만드는 REST의 규칙들은 무엇이 있을까?&lt;/p&gt;

&lt;h3 id=&quot;rest의-규칙&quot;&gt;REST의 규칙&lt;/h3&gt;

&lt;h4 id=&quot;1-uniform-interface&quot;&gt;1. Uniform Interface&lt;/h4&gt;

&lt;p&gt;app 이 뭐든 간에 server랑 상호작용하는 일관된 방법이 있어야 한다. 그러러면 어떻게 해야 할까?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;self-descriptive message&lt;/strong&gt; 메시지는 스스로를 설명해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HATEOAS&lt;/strong&gt; 애플리케이션의 상태는 Hyperlink를 통해 전이되어야 한다.&lt;/p&gt;

&lt;h4 id=&quot;2-client-server&quot;&gt;2. Client-Server&lt;/h4&gt;

&lt;p&gt;client server 가 독립적으로 상호 의존성없이 발전할 수 있어야 한다. 이 규칙을 지켰기 때문에 우리가 웹 브라우저가 업데이트됐다고 웹 페이지를 업데이트 하지 않아도 되는 것이다. 😛그리고 이는 둘 간의 interface가 수정되지 않으면 가능한 일.&lt;/p&gt;

&lt;h4 id=&quot;3-stateless&quot;&gt;3. Stateless&lt;/h4&gt;

&lt;p&gt;Server 는 이전 HTTP request 등을 전혀 저장하지 않아야 한다. No session, No history.&lt;/p&gt;

&lt;h4 id=&quot;4-cacheable&quot;&gt;4. Cacheable&lt;/h4&gt;

&lt;h4 id=&quot;5-layered-system&quot;&gt;5. Layered system&lt;/h4&gt;

&lt;p&gt;layered system architecture 를 사용할 수 있다. 예를 들면, 모든 API는 server A에서 handle하고 데이터는 모두 server B에 저장하고, 인증관련은 다 server C에서 처리하고 등등..&lt;/p&gt;

&lt;h4 id=&quot;6-code-on-demandoptional&quot;&gt;6. Code on demand(optional)&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;실행가능한 코드&lt;/code&gt;를 메시지로 돌려줄 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;요새 수많은 api 가 스스로를 RESTful API라고 칭하고 있는데 그 중에 이 규칙을 모두 만족하거나 심지어 중요한 것들 만이라도 만족하지 않는게 대다수 ..  한번씩 더 생각해 볼 필요가 있는 것 같다. 그냥 HTTP API 라고 부르든지.. 로이 필딩 선생님 답답하신 듯. 🧘🏻‍&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;https://www.youtube.com/watch?v=0cfUVrQW_yg&lt;/p&gt;

&lt;p&gt;https://opentutorials.org/course/228/4894&lt;/p&gt;

&lt;p&gt;https://restfulapi.net/rest-architectural-constraints/&lt;/p&gt;

&lt;p&gt;http://slides.com/eungjun/rest#/40&lt;/p&gt;</content><author><name>JJIONI</name></author><category term="Network, HTTPS" /><summary type="html">~ 기본을 정확히 알자 ~</summary></entry><entry><title type="html">용어 정리집 - Cloud Computing 편</title><link href="http://localhost:4000/computer%20science/it-terms/" rel="alternate" type="text/html" title="용어 정리집 - Cloud Computing 편" /><published>2020-04-20T00:00:00+00:00</published><updated>2020-04-20T22:42:00+00:00</updated><id>http://localhost:4000/computer%20science/it-terms</id><content type="html" xml:base="http://localhost:4000/computer%20science/it-terms/">&lt;h2 id=&quot;big-data&quot;&gt;Big Data&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;한대의 컴퓨터로는 저장하거나 연산하기 어려운 규모의 거대 데이터&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;scale-up--scale-out-비교&quot;&gt;Scale UP &amp;amp; Scale Out 비교&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Scale Up&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기존 장치에 필요한 부품을 추가해서 성능 향상 (ex, 디스크 증설, RAM 용량 확장…)&lt;/p&gt;

&lt;p&gt;상대적으로 비용이 적게 발생하나, 용량 확장에 제약이 있음&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Scale Out&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;성능 향상을 위해 장비를 추가하여 병렬로 사용하는 방식&lt;/p&gt;

&lt;p&gt;추가된 장비가 기존 장비와 하나의 System으로 운영되기 위한 별도의 장비가 필요!&lt;/p&gt;

&lt;p&gt;그렇다고 해서 무한정 확장되는 건 아님&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;비교&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;웹사이트의 트래픽 증가하는 경우 scale out이 일반적으로 scale up	보단 효과적이며 비용도 저렴!&lt;/p&gt;

&lt;p&gt;하지만, DB의 빈번한 갱신이 필요한 OLTP(online transcation)의 경우 scale up이 효과적&lt;/p&gt;

&lt;h3 id=&quot;cloud-computing-service&quot;&gt;Cloud Computing Service&lt;/h3&gt;

&lt;p&gt;–&amp;gt; 컴퓨터를 사용한 정보 처리를 보유 PC가 아니라 인터넷 너머 어딘가에 존재하는 클라우드 사업자의 컴퓨터에서 처리하는 서비스&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Saas (Software as a Service)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;주로 업무에서 사용하는 SW기능을 인터넷 네트워크를 통해 필요한 만큼만 서비스로 제공&lt;/p&gt;

&lt;p&gt;Hw, os, middle ware, application까지 구축되어 있는 SW를 서비스로 이용하는 것&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Paas (Platfrom as a Service)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기업의 application 실행 환경 및 application 개발 환경을 서비스로 제공하는 모델&lt;/p&gt;

&lt;p&gt;(EX) java,php,ruby 등의 프로그래밍 언어를 지원하는 어플리케이션 실행 환경이나 DB등이 미리 마련되어 있어 단기간에 application 개발하여 런치 가능&lt;/p&gt;

&lt;p&gt;기본 인프라(일반적으로 하드웨어나 운영체제)를 관리할 필요가 없다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Iass (Infrastructure as a Service)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CPU/HW 와 같은 컴퓨팅 리소스를 네트워크를 통해 서비스로 제공하는 모델&lt;/p&gt;

&lt;p&gt;(EX) 가상 서버, 온라인 스토리지 등&lt;/p&gt;

&lt;h3 id=&quot;가상화&quot;&gt;가상화&lt;/h3&gt;

&lt;h3 id=&quot;hadoop&quot;&gt;Hadoop&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;빅데이터&lt;/strong&gt;의 &lt;strong&gt;저장&lt;/strong&gt;과 &lt;strong&gt;분석&lt;/strong&gt;을 위한 &lt;strong&gt;분산 컴퓨팅&lt;/strong&gt; 솔루션&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;분산&lt;/strong&gt; : 여러 대의 컴퓨터로 나눠서 일을 처리함&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;분석&lt;/strong&gt; : 데이터가 저장된 컴퓨터에서 데이터를 분석하고 그 결과를 합친다&lt;/p&gt;

&lt;h2 id=&quot;name-node-data-node&quot;&gt;Name Node, Data Node&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;각 컴퓨터마다. 가상 머신을 만들어서 한 대는 name node, 한 대는 data node, 이런 식으로 구성 가능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Name Node&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파일을 쪼개주는 역할, 쪼개진 파일이 어느 데이터 노드에 저장되어 있는가를 기억하고 있다. Meta Data&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Data Node&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;쪼개진 데이터를 보관하고 있는 노드&lt;/p&gt;

&lt;h2 id=&quot;overally&quot;&gt;Overally…&lt;/h2&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;https://www.youtube.com/watch?v=HCR1ILMROfI&amp;amp;list=PLKOJg3-beila7LPuySi6JVAkB-1YZSZB_&lt;/p&gt;

&lt;p&gt;https://velog.io/@jyebe/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%BB%B4%ED%93%A8%ED%8C%85-%EA%B0%9C%EB%85%90-%EB%B0%8F-SaaS-PaaS-IaaS-%EB%B9%84%EA%B5%90&lt;/p&gt;</content><author><name>JJIONI</name></author><category term="Big Data, Cloud Computing" /><summary type="html">알아들어야 할 때를 위한 용어 정리집 - Cloud Computing 편</summary></entry><entry><title type="html">자료구조 - 1</title><link href="http://localhost:4000/computer%20science/data-structure/" rel="alternate" type="text/html" title="자료구조 - 1" /><published>2020-04-20T00:00:00+00:00</published><updated>2020-04-20T22:42:00+00:00</updated><id>http://localhost:4000/computer%20science/data-structure</id><content type="html" xml:base="http://localhost:4000/computer%20science/data-structure/"></content><author><name>JJIONI</name></author><category term="Data Structure" /><summary type="html">Hash Map 과 Tree</summary></entry><entry><title type="html">github.io 블로그 시작하기</title><link href="http://localhost:4000/blog/first-post/" rel="alternate" type="text/html" title="github.io 블로그 시작하기" /><published>2020-04-12T00:00:00+00:00</published><updated>2020-04-12T22:42:00+00:00</updated><id>http://localhost:4000/blog/first-post</id><content type="html" xml:base="http://localhost:4000/blog/first-post/">&lt;p&gt;github.io 블로그를 시작하기로 했다..&lt;/p&gt;

&lt;p&gt;이것저것 만지니까 꽤 재밌잖아!?!?!&lt;/p&gt;

&lt;p&gt;심지어 좀 귀여운듯 🙄&lt;/p&gt;</content><author><name>JJIONI</name></author><category term="Blog" /><summary type="html">GitHub Blog 서비스인 github.io 블로그 시작하기로 했다.</summary></entry></feed>